<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <!-- 李可 -->
    <style>
        #Timing {
            display: flex;
            justify-content:center;
            align-items:center;

            width: 400px;
            height: 200px;
            background: #444444;
            color: white;
            font-size: 4em;
        }
    </style>
</head>

<body>
    <div id="Timing">1</div>
    <script>
        /**
         *如果你持续触发事件，每隔一段时间，只执行一次事件
         *+new Date()==Date.now()//√
         *+new Date==Date.now()//√
         *+new Date()==+new Date==Date.now()
         */
        var throttle = function (fn, delay, scope) {
            scope = scope || this
            delay = delay || 1000
            var args = arguments

            var previous = 0
            var delayFn = function () {
                var now = Date.now()
                var run = now - previous > delay
                if (run) {
                    fn.apply(scope, args)
                    previous = now
                }
            }
            return delayFn
        }
        /** 跨时间函数用到外部的变量会被缓存（因为有被引用的变量[包括字符串、对象、方法]会被缓存下来，而且缓存下的这些变量会保持当时的运行环境），等到用到的时候（跨时间），其实用了缓存的东西
         * 1，外层函数返回的内层函数（引用外层函数的变量）闭包
         * 2，对象的属性函数（引用对象其他属性）
         * 3，dom事件对象的函数引用外层的变量这里的start
         */
        // var start = 0
        // Timing.onmousemove = function () {
        //     Timing.innerHTML = ++start
        // }
        var start = 0
        Timing.onmousemove = throttle(function () {
            Timing.innerHTML = ++start
        })
    </script>
</body>

</html>