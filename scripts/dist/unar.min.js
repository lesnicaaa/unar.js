
/**
*   Unar.js v0.0.1
*   (c) 2017-2018 author:like
*   Released under the MIT License.
*/ 

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.Unar = factory());
}(this, (function () { 'use strict';

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

/**
 * DomEvent
 */
var DomEvent = function () {
	function DomEvent() {
		classCallCheck(this, DomEvent);
	}

	createClass(DomEvent, null, [{
		key: "model",
		value: function model(node, val, oldValue) {
			if (val !== oldValue) {
				node.value = val;
			}
		}
	}, {
		key: "text",
		value: function text(node, _text, oldTxt) {
			if (_text !== oldTxt) {
				node.textContent = _text;
			}
		}
	}, {
		key: "html",
		value: function html(node, _html) {
			node.innerHTML = _html;
		}
	}, {
		key: "bind",
		value: function bind(node, attrName, attrVal) {
			node[attrName.substr(config.attrPrefix.length, attrName.length)] = attrVal;
		}
	}, {
		key: "addEvt",
		value: function addEvt(node, evtName, fn) {
			node.addEventListener(evtName, fn, false);
		}
	}]);
	return DomEvent;
}();

var propType = {
    switch: undefined
    //console 
};window.propType = propType;

/**
 * one vm prop <---> one Hub
 */

// a:{id: 1, prop: "a", listeners: [cb1,cb2]
// b:{id: 2, prop: "b", listeners: [cb3,cb4]
var hubs = {};

window.hubs = hubs;
var id = 0;

var Hub = function () {
	function Hub(prop, cb, vm) {
		classCallCheck(this, Hub);

		this.id = ++id;
		this.prop = prop;
		this.val = vm[prop];
		this.vm = vm;
		this.listeners = [];
		this.addListener(cb);
	}

	createClass(Hub, [{
		key: "addListener",
		value: function addListener(cb) {
			this.listeners.push(cb);
		}
	}, {
		key: "deleteListener",
		value: function deleteListener() {}
	}, {
		key: "notify",
		value: function notify() {
			var _this = this;

			this.listeners.forEach(function (fn) {
				//oldVal->this.val
				//val->this.vm[this.prop]
				fn.call(_this.vm, _this.vm[_this.prop], _this.val);
			});
			//update val to oldVal
			this.val = this.vm[this.prop];
		}
	}]);
	return Hub;
}();

var count = 0;

var Register = function () {
	function Register() {
		classCallCheck(this, Register);
	}

	createClass(Register, null, [{
		key: "registDomListener4Hubs",
		value: function registDomListener4Hubs(detictive, node, key, vm) {
			if (vm.computeds[key]) {
				//count several nodes ->samecomputed prop
				propType.switch = key + ++count;
				var ccb = function ccb() {
					DomEvent[detictive](node, vm[key]);
				};
				propType[key + count] = ccb;
				ccb();
			} else {
				var cb = function cb(val, oldVal) {
					DomEvent[detictive](node, val, oldVal);
				};
				cb(vm[key]);
				this.registListener4Hubs(key, cb, vm);
			}
		}
	}, {
		key: "registListener4Hubs",
		value: function registListener4Hubs(key, cb, vm) {
			hubs[key] ? hubs[key].listeners.push(cb) : hubs[key] = new Hub(key, cb, vm);
		}
	}]);
	return Register;
}();

var proxy = function proxy(data, vm) {
	Object.keys(data).forEach(function (key) {
		//Data properties->data[key]
		//it's cached,data[key] can replaced by vm._data[key],vm.$options.data,o.data 
		var valCache = data[key];

		//Accessor properties
		//data reference->At the same time, vm._data ,vm.$options.data, o.data become three accessor properties
		Object.defineProperty(data, key, {
			configurable: false,
			enumerable: true,
			get: function get$$1() {
				//vm._data[key],vm.$options.data[key],data[key]
				//maximum call stack size exceeded

				//computeds
				var currentComputedType = propType.switch;
				if (currentComputedType) {
					var cfn = function cfn() {
						propType[currentComputedType]();
						vm.computeds[currentComputedType.substring(0, currentComputedType.length - 1)]();
					};
					Register.registListener4Hubs(key, cfn, vm);
				}
				return valCache;
			},
			set: function set$$1(newVal) {
				valCache = newVal;
				//set value first,then notify dom update with newVal
				hubs[key].notify();
			}
		});

		Object.defineProperty(vm, key, {
			configurable: false,
			enumerable: true,
			get: function get$$1() {
				//it can replaced by this._data[key],this.$options.data[key] ,o.data[key]
				//not allow valCache
				//this will call get above
				return data[key];
			},
			set: function set$$1(newVal) {
				data[key] = newVal;
			}
		});
	});
};
var watch = function watch(watchers, vm) {
	//Object.entries({a:1})-->[["a", 1]]
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = Object.entries(watchers)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var _ref = _step.value;

			var _ref2 = slicedToArray(_ref, 2);

			var key = _ref2[0];
			var cb = _ref2[1];

			Register.registListener4Hubs(key, cb, vm);
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}
};

var compute = function compute(computeds, vm) {
	/**
  * 	var o={}
 	Object.defineProperty(o, 'a', {
 		get: function () {return 1 },
 		set: function () { }
 	})
 	Object.getOwnPropertyDescriptor(o,'a')
 	{get: ƒ, set: ƒ, enumerable: false, configurable: false}
  */
	var _iteratorNormalCompletion2 = true;
	var _didIteratorError2 = false;
	var _iteratorError2 = undefined;

	try {
		for (var _iterator2 = Object.entries(computeds)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
			var _ref3 = _step2.value;

			var _ref4 = slicedToArray(_ref3, 2);

			var key = _ref4[0];
			var fn = _ref4[1];

			Object.defineProperty(vm, key, {
				configurable: false,
				enumerable: true,
				get: fn,
				set: function set$$1() {}
			});
		}
	} catch (err) {
		_didIteratorError2 = true;
		_iteratorError2 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion2 && _iterator2.return) {
				_iterator2.return();
			}
		} finally {
			if (_didIteratorError2) {
				throw _iteratorError2;
			}
		}
	}
};

// import C from './index.js'
// console.log(C)

var a = "1";

var C = function C() {
	classCallCheck(this, C);

	this.props = '2';
};

C.staticProp = [];

//Unar.global={
console.log(C, a);

var config$1 = {
    actionPrefix: "u",
    attrPrefix: ":",
    evtPrefix: "@"
};

var Attr = function () {
    function Attr() {
        classCallCheck(this, Attr);
    }

    createClass(Attr, null, [{
        key: "isExpression",
        value: function isExpression(txt) {
            return (/\{\{.*\}\}/.test(txt)
            );
        }
    }, {
        key: "expressionKey",
        value: function expressionKey(txt) {
            return txt.match(/(.*)\{\{(.*)\}\}(.*)/);
        }
    }, {
        key: "isAction",
        value: function isAction(attr) {
            //u
            return attr.indexOf(config$1.actionPrefix) === 0;
        }
    }, {
        key: "isProp",
        value: function isProp(attr) {
            //: v-bind:a="a"
            return attr.indexOf(config$1.PropPrefix) === 0;
        }
    }, {
        key: "isEvt",
        value: function isEvt(attr) {
            //: v-bind:a="a"
            return attr.indexOf(config$1.evtPrefix) === 0;
        }
    }]);
    return Attr;
}();

/**
 * Detictive
 */

var Detictive = function () {
	function Detictive() {
		classCallCheck(this, Detictive);
	}

	createClass(Detictive, null, [{
		key: config$1.actionPrefix + "-model",
		value: function value(node, key, vm) {
			Register.registDomListener4Hubs("model", node, key, vm);
			node.addEventListener('input', function (e) {
				vm[key] = e.target.value;
			}, false);
		}
		// {{}}&&text

	}, {
		key: "text",
		value: function text(node, key, vm) {

			Register.registDomListener4Hubs("text", node, key, vm);
		}
		// , vm

	}, {
		key: config$1.actionPrefix + "-html",
		value: function value(node, html) {
			Register.registDomListener4Hubs("html", node, html);
		}
		//:
		// static bind(node, attrName, attrVal) {
		// 	DomFn.bind(node, attrName, attrVal)
		// }
		// //@
		// static addEvt(node, attrName, fn) {
		// 	var evtName = attrName.substr(config.evtPrefix.length, attrName.length)
		// 	var fn = this.methods[fn].bind(this)
		// 	DomFn.addEvt(node, evtName, fn)
		// }

	}]);
	return Detictive;
}();

/**
 * Templater
 */

var Templater = function () {
	function Templater(selector, vm) {
		classCallCheck(this, Templater);

		this.vm = vm;
		this.el = document.querySelector(selector);
		if (this.el) {
			this.el.appendChild(this.init());
		}
	}

	createClass(Templater, [{
		key: "init",
		value: function init() {
			var _this = this;

			var fragment = document.createDocumentFragment();
			this.filterNode2fragment(fragment);
			//初始化view
			fragment.childNodes.forEach(function (node) {
				_this.initAttrEvt(node);
			});
			console.log(fragment);
			// for (let node of fragment.childNodes) {
			//     this.initAttrEvt(node)
			// }
			return fragment;
		}
	}, {
		key: "filterNode2fragment",
		value: function filterNode2fragment(fragment) {
			//所有节点node
			for (var i = 0; i < this.el.childNodes.length; i++) {
				var node = this.el.childNodes[i];
				var nodeType = node.nodeType;
				//for reduce the loop count ,filter nodes to Element Comment Text(not contain pure whitespace)
				if (nodeType === 1 || nodeType === 8 || nodeType === 3 && !this._isPureBlankNode(node)) {
					fragment.appendChild(node);
					--i;
				}
			}
		}
	}, {
		key: "initAttrEvt",
		value: function initAttrEvt(node) {
			var _this2 = this;

			//排除元素、文本以外的节点
			if (node.nodeType === 1) {
				//node.attributes
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;

				try {
					for (var _iterator = node.attributes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var attr = _step.value;

						//过滤掉非unar的动作、属性、事件
						var detec = attr.nodeName;
						var key = attr.nodeValue;
						//u-html u-model
						if (Attr.isAction(detec)) {
							Detictive[detec](node, key, this.vm);
							continue;
						}
						// //:id
						// if (Attr.isProp(detec)) {
						//     Detective.bind(node, detec, key, this.vm)
						//     continue
						// }
						// //@click
						// if (Attr.isEvt(detec)) {
						//     Detective.addEvt.call(this.vm, node, detec, key)
						//     continue
						// }
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator.return) {
							_iterator.return();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}

				node.childNodes.forEach(function (childNode) {
					_this2.initAttrEvt(childNode);
				});
			}
			//text with {{}}
			if (node.nodeType === 3) {
				if (Attr.isExpression(node.data)) {
					// preText,nextText
					var _Attr$expressionKey = Attr.expressionKey(node.data),
					    _Attr$expressionKey2 = slicedToArray(_Attr$expressionKey, 3),
					    keyText = _Attr$expressionKey2[2];

					Detictive['text'](node, keyText, this.vm);
					//continue
				}
			}
		}
		/**
   * https://developer.mozilla.org/zh-CN/docs/Web/Guide/API/DOM/Whitespace_in_the_DOM
   * 以下所谓的“空白符”代表：
   *  "\t" TAB \u0009 （制表符）
   *  "\n" LF  \u000A （换行符）
   *  "\r" CR  \u000D （回车符）
   *  " "  SPC \u0020 （真正的空格符）
   *
   * 不包括 JavaScript 的“\s”，因为那代表如不断行字符等其他字符。
   */
		/**
   * 测知某节点的文字内容是否全为空白。
   *
   * @参数   nod  |CharacterData| 类的节点（如  |Text|、|Comment| 或 |CDATASection|）。
   * @传回值      若 |nod| 的文字内容全为空白则传回 true，否则传回 false。
   */

	}, {
		key: "_isPureBlankNode",
		value: function _isPureBlankNode(node) {
			// Use ECMA-262 Edition 3 String and RegExp features
			return !/[^\t\n\r ]/.test(node.data);
		}
	}]);
	return Templater;
}();

/**
 * Unar
 */

var Unar =
// static hubs = []
function Unar(_ref) {
		var _ref$el = _ref.el,
		    el = _ref$el === undefined ? '' : _ref$el,
		    _ref$data = _ref.data,
		    data = _ref$data === undefined ? {} : _ref$data,
		    _ref$computeds = _ref.computeds,
		    computeds = _ref$computeds === undefined ? {} : _ref$computeds,
		    _ref$methods = _ref.methods,
		    methods = _ref$methods === undefined ? {} : _ref$methods,
		    _ref$watchers = _ref.watchers,
		    watchers = _ref$watchers === undefined ? {} : _ref$watchers;
		classCallCheck(this, Unar);

		this.methods = methods;
		//this.$options = {}

		//this add keys(_data、$options )
		//var data = this._data = this.$options.data = data

		//hijack properties
		//change data properties to accessor properties
		proxy(data, this);

		//add computed properties to this
		this.computeds = computeds;
		compute(this.computeds, this);

		//console.log(this)
		//add watchers properties to this
		this.watchers = watchers;
		watch(this.watchers, this);

		// if the template does not define the properties of the data,
		// it will not subscribe to the hubs inside the event

		//compile fragment
		new Templater(el, this);
}
// $watch() {}
// static use() {}
// static extend() {}
// static $nextTick() {}
// $get() {
//     //utils.get(this, key, val)
// }
// $set() {
//     utils.set(this, key, val)
// }
// $created() {}
// $mounted() {}
// $computed() {}
// $remove() {}
// $destroy() {}
// $before() {}
// $after() {}
// 'emit', 'on', 'off', 'once'
;

return Unar;

})));
